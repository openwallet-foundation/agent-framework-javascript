import { EncryptedMessage, Wallet } from '@aries-framework/core'

export class DIDCommV1Packer {
  private wallet: Wallet

  /**
   * Pack a message using DIDComm V1 algorithm
   *
   * @param payload message to send
   * @param recipientKeys array containing recipient keys in base58
   * @param senderVerkey sender key in base58
   * @returns JWE Envelope to send
   */
  public async pack(
    payload: Record<string, unknown>,
    recipientKeys: string[],
    senderVerkey?: string // in base58
  ): Promise<EncryptedMessage> {
    const cek = AskarKey.generate(KeyAlgs.Chacha20C20P)

    this.wallet.generateWalletKey()
    const senderKey = senderVerkey ? await this.session.fetchKey({ name: senderVerkey }) : undefined

    const senderExchangeKey = senderKey ? senderKey.key.convertkey({ algorithm: KeyAlgs.X25519 }) : undefined

    const recipients: JweRecipient[] = []

    for (const recipientKey of recipientKeys) {
      const targetExchangeKey = AskarKey.fromPublicBytes({
        publicKey: Key.fromPublicKeyBase58(recipientKey, KeyType.Ed25519).publicKey,
        algorithm: KeyAlgs.Ed25519,
      }).convertkey({ algorithm: KeyAlgs.X25519 })

      if (senderVerkey && senderExchangeKey) {
        const encryptedSender = CryptoBox.seal({
          recipientKey: targetExchangeKey,
          message: Buffer.from(senderVerkey),
        })
        const nonce = CryptoBox.randomNonce()
        const encryptedCek = CryptoBox.cryptoBox({
          recipientKey: targetExchangeKey,
          senderKey: senderExchangeKey,
          message: cek.secretBytes,
          nonce,
        })

        recipients.push(
          new JweRecipient({
            encryptedKey: encryptedCek,
            header: {
              kid: recipientKey,
              sender: TypedArrayEncoder.toBase64URL(encryptedSender),
              iv: TypedArrayEncoder.toBase64URL(nonce),
            },
          })
        )
      } else {
        const encryptedCek = CryptoBox.seal({
          recipientKey: targetExchangeKey,
          message: cek.secretBytes,
        })
        recipients.push(
          new JweRecipient({
            encryptedKey: encryptedCek,
            header: {
              kid: recipientKey,
            },
          })
        )
      }
    }

    const protectedJson = {
      enc: 'xchacha20poly1305_ietf',
      typ: 'JWM/1.0',
      alg: senderVerkey ? 'Authcrypt' : 'Anoncrypt',
      recipients: recipients.map((item) => JsonTransformer.toJSON(item)),
    }

    const { ciphertext, tag, nonce } = cek.aeadEncrypt({
      message: Buffer.from(JSON.stringify(payload)),
      aad: Buffer.from(JsonEncoder.toBase64URL(protectedJson)),
    }).parts

    const envelope = new JweEnvelope({
      ciphertext: TypedArrayEncoder.toBase64URL(ciphertext),
      iv: TypedArrayEncoder.toBase64URL(nonce),
      protected: JsonEncoder.toBase64URL(protectedJson),
      tag: TypedArrayEncoder.toBase64URL(tag),
    }).toJson()

    return envelope as EncryptedMessage
  }

  /**
   * Unpacks a JWE Envelope coded using DIDComm V1 algorithm
   *
   * @param messagePackage JWE Envelope
   * @returns UnpackedMessageContext with plain text message, sender key and recipient key
   */
  public async unpack(messagePackage: EncryptedMessage): Promise<UnpackedMessageContext> {
    const protectedJson = JsonEncoder.fromBase64(messagePackage.protected)

    const alg = protectedJson.alg
    const isAuthcrypt = alg === 'Authcrypt'

    if (!isAuthcrypt && alg != 'Anoncrypt') {
      throw new WalletError(`Unsupported pack algorithm: ${alg}`)
    }

    const recipients = []

    for (const recip of protectedJson.recipients) {
      const kid = recip.header.kid
      if (!kid) {
        throw new WalletError('Blank recipient key')
      }
      const sender = recip.header.sender ? TypedArrayEncoder.fromBase64(recip.header.sender) : undefined
      const iv = recip.header.iv ? TypedArrayEncoder.fromBase64(recip.header.iv) : undefined
      if (sender && !iv) {
        throw new WalletError('Missing IV')
      } else if (!sender && iv) {
        throw new WalletError('Unexpected IV')
      }
      recipients.push({
        kid,
        sender,
        iv,
        encrypted_key: TypedArrayEncoder.fromBase64(recip.encrypted_key),
      })
    }

    let payloadKey, senderKey, recipientKey

    for (const recipient of recipients) {
      let recipientKeyEntry
      try {
        recipientKeyEntry = await this.session.fetchKey({ name: recipient.kid })
      } catch (error) {
        // TODO: Currently Askar wrapper throws error when key is not found
        // In this case we don't need to throw any error because we should
        // try with other recipient keys
        continue
      }
      if (recipientKeyEntry) {
        const recip_x = recipientKeyEntry.key.convertkey({ algorithm: KeyAlgs.X25519 })
        recipientKey = recipient.kid

        if (recipient.sender && recipient.iv) {
          senderKey = TypedArrayEncoder.toUtf8String(
            CryptoBox.sealOpen({
              recipientKey: recip_x,
              ciphertext: recipient.sender,
            })
          )
          const sender_x = AskarKey.fromPublicBytes({
            algorithm: KeyAlgs.Ed25519,
            publicKey: decodeFromBase58(senderKey),
          }).convertkey({ algorithm: KeyAlgs.X25519 })

          payloadKey = CryptoBox.open({
            recipientKey: recip_x,
            senderKey: sender_x,
            message: recipient.encrypted_key,
            nonce: recipient.iv,
          })
        }
        break
      }
    }
    if (!payloadKey) {
      throw new WalletError('No corresponding recipient key found')
    }

    if (!senderKey && isAuthcrypt) {
      throw new WalletError('Sender public key not provided for Authcrypt')
    }

    const cek = AskarKey.fromSecretBytes({ algorithm: KeyAlgs.Chacha20C20P, secretKey: payloadKey })
    const message = cek.aeadDecrypt({
      ciphertext: TypedArrayEncoder.fromBase64(messagePackage.ciphertext as any),
      nonce: TypedArrayEncoder.fromBase64(messagePackage.iv as any),
      tag: TypedArrayEncoder.fromBase64(messagePackage.tag as any),
      aad: TypedArrayEncoder.fromString(messagePackage.protected),
    })
    return {
      plaintextMessage: JsonEncoder.fromBuffer(message),
      senderKey,
      recipientKey,
    }
  }
}
